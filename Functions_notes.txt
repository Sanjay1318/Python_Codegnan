===========================================================
    PYTHON FUNCTIONS - COMPLETE GUIDE OF PYTHON FUNCTIONS.
===========================================================

BASIC CONCEPTS
--------------
A function is a block of code with a particular functionality
Its executed only when the function is called
Functions help in code reusability and modularity

===========================================================
                    BASIC FUNCTIONS
===========================================================

1. FUNCTION DEFINITION
   - A function is defined using the 'def' keyword
   - Syntax:
     def function_name(parameters):
         """docstring (optional)"""
         # function body
         return value (optional)

   Example:
   def greet():
       print("Hello, World!")
       return "Done"

2. FUNCTION CALLING
   - Functions are called using function name followed by parentheses
   - Example: greet()

   def greet():
       print("Hello, World!")
   
   greet()  # Calling the function
   greet()  # Can be called multiple times

===========================================================
                PARAMETERS & ARGUMENTS
===========================================================

1. POSITIONAL ARGUMENTS
   - Arguments passed in the order of parameters
   
   def introduce(name, age):
       print(f"My name is {name} and I am {age} years old")
   
   introduce("John", 25)  # name="John", age=25

2. KEYWORD ARGUMENTS
   - Arguments passed with parameter names
   
   def introduce(name, age):
       print(f"My name is {name} and I am {age} years old")
   
   introduce(age=25, name="John")  # Order doesn't matter

3. DEFAULT PARAMETERS
   - Parameters with default values
   - Default parameters must come after non-default parameters
   
   def greet(name, message="Hello"):
       print(f"{message}, {name}!")
   
   greet("John")              # Output: Hello, John!
   greet("John", "Hi")        # Output: Hi, John!

4. *ARGS (VARIABLE POSITIONAL ARGUMENTS)
   - Accepts multiple positional arguments as a tuple
   
   def sum_all(*args):
       total = 0
       for num in args:
           total += num
       return total
   
   print(sum_all(1, 2, 3, 4, 5))  # Output: 15
   print(sum_all(10, 20))         # Output: 30

5. **KWARGS (VARIABLE KEYWORD ARGUMENTS)
   - Accepts multiple keyword arguments as a dictionary
   
   def print_info(**kwargs):
       for key, value in kwargs.items():
           print(f"{key}: {value}")
   
   print_info(name="John", age=25, city="NYC")
   # Output:
   # name: John
   # age: 25
   # city: NYC

6. COMBINING *ARGS AND **KWARGS
   def mixed_function(*args, **kwargs):
       print("Positional arguments:", args)
       print("Keyword arguments:", kwargs)
   
   mixed_function(1, 2, 3, name="John", age=25)
   # Output:
   # Positional arguments: (1, 2, 3)
   # Keyword arguments: {'name': 'John', 'age': 25}

===========================================================
                    RETURN VALUES
===========================================================

1. RETURN SINGLE VALUE
   def add(a, b):
       return a + b
   
   result = add(5, 3)  # result = 8

2. RETURN MULTIPLE VALUES
   - Python automatically returns a tuple
   
   def get_stats(numbers):
       return min(numbers), max(numbers), sum(numbers)/len(numbers)
   
   minimum, maximum, average = get_stats([1, 2, 3, 4, 5])
   # minimum=1, maximum=5, average=3.0

3. RETURN NOTHING (None)
   - If no return statement, function returns None
   
   def greet(name):
       print(f"Hello, {name}!")
       # No return statement
   
   result = greet("John")  # result = None

4. EARLY RETURN
   - Using return to exit function early
   
   def find_first_even(numbers):
       for num in numbers:
           if num % 2 == 0:
               return num
       return None

===========================================================
                    LAMBDA FUNCTIONS
===========================================================

1. BASIC LAMBDA
   - Anonymous functions (no name)
   - Syntax: lambda arguments: expression
   
   square = lambda x: x ** 2
   print(square(5))  # Output: 25

2. LAMBDA WITH MULTIPLE ARGUMENTS
   add = lambda a, b: a + b
   print(add(3, 5))  # Output: 8

3. COMMON LAMBDA USES
   - With built-in functions like map(), filter(), sorted()
   
   # map() - applies function to all items
   numbers = [1, 2, 3, 4, 5]
   squared = list(map(lambda x: x**2, numbers))
   print(squared)  # [1, 4, 9, 16, 25]
   
   # filter() - filters based on condition
   numbers = [1, 2, 3, 4, 5, 6]
   evens = list(filter(lambda x: x % 2 == 0, numbers))
   print(evens)  # [2, 4, 6]
   
   # sorted() with key
   names = ["Charlie", "Alice", "Bob"]
   sorted_names = sorted(names, key=lambda x: len(x))
   print(sorted_names)  # ['Bob', 'Alice', 'Charlie']

===========================================================
                NESTED FUNCTIONS
===========================================================

1. FUNCTION INSIDE FUNCTION
   def outer_function():
       print("Outer function")
       
       def inner_function():
           print("Inner function")
       
       inner_function()  # Can only be called inside outer_function()
   
   outer_function()

2. CLOSURES
   - Inner function that remembers variables from outer function's scope
   
   def outer(x):
       def inner(y):
           return x + y
       return inner
   
   add_five = outer(5)
   print(add_five(10))  # Output: 15

3. PRACTICAL CLOSURE EXAMPLE
   def make_multiplier(factor):
       def multiplier(number):
           return number * factor
       return multiplier
   
   double = make_multiplier(2)
   triple = make_multiplier(3)
   
   print(double(5))  # 10
   print(triple(5))  # 15

===========================================================
                    DECORATORS
===========================================================

1. BASIC DECORATOR
   - Function that wraps another function to add functionality
   
   def my_decorator(func):
       def wrapper():
           print("Before function call")
           func()
           print("After function call")
       return wrapper
   
   @my_decorator
   def say_hello():
       print("Hello!")
   
   say_hello()
   # Output:
   # Before function call
   # Hello!
   # After function call

2. DECORATOR WITH ARGUMENTS
   def repeat(times):
       def decorator(func):
           def wrapper(*args, **kwargs):
               for _ in range(times):
                   result = func(*args, **kwargs)
               return result
           return wrapper
       return decorator
   
   @repeat(times=3)
   def greet(name):
       print(f"Hello, {name}!")
   
   greet("John")
   # Prints "Hello, John!" 3 times

3. PRESERVING FUNCTION METADATA
   - Use functools.wraps to preserve original function's metadata
   
   from functools import wraps
   
   def my_decorator(func):
       @wraps(func)
       def wrapper(*args, **kwargs):
           """Wrapper function"""
           print("Function is being called")
           return func(*args, **kwargs)
       return wrapper
   
   @my_decorator
   def example():
       """Example function"""
       pass
   
   print(example.__name__)  # Output: example (not wrapper)
   print(example.__doc__)   # Output: Example function

===========================================================
                    GENERATORS
===========================================================

1. BASIC GENERATOR
   - Functions that yield values instead of returning
   - Use 'yield' keyword instead of 'return'
   - Memory efficient for large datasets
   
   def count_up_to(n):
       count = 1
       while count <= n:
           yield count
           count += 1
   
   for num in count_up_to(5):
       print(num)  # Prints 1, 2, 3, 4, 5

2. GENERATOR EXPRESSIONS
   - Similar to list comprehensions but memory efficient
   
   squares = (x**2 for x in range(10))
   print(list(squares))  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

3. YIELD FROM
   - Delegates to another generator
   
   def chain(*generators):
       for gen in generators:
           yield from gen
   
   for num in chain([1, 2], [3, 4], [5, 6]):
       print(num)  # 1, 2, 3, 4, 5, 6

===========================================================
                    RECURSION
===========================================================

1. BASIC RECURSION
   - Function that calls itself
   
   def factorial(n):
       if n <= 1:
           return 1
       return n * factorial(n - 1)
   
   print(factorial(5))  # Output: 120

2. FIBONACCI WITH RECURSION
   def fibonacci(n):
       if n <= 1:
           return n
       return fibonacci(n-1) + fibonacci(n-2)
   
   for i in range(10):
       print(fibonacci(i), end=" ")  # 0 1 1 2 3 5 8 13 21 34

3. RECURSION WITH MEMOIZATION
   from functools import lru_cache
   
   @lru_cache(maxsize=None)
   def fibonacci_memo(n):
       if n <= 1:
           return n
       return fibonacci_memo(n-1) + fibonacci_memo(n-2)
   
   print(fibonacci_memo(100))  # Much faster!

===========================================================
                    SCOPE (LEGB RULE)
===========================================================

LEGB Rule: Python looks for variables in order:
1. Local - Inside current function
2. Enclosing - Inside enclosing functions
3. Global - At module level
4. Built-in - Python's built-in names

1. LOCAL SCOPE
   x = 10
   def local_example():
       x = 5  # This is a LOCAL variable
       print(x)  # Prints 5
   
   local_example()
   print(x)  # Prints 10

2. GLOBAL SCOPE
   x = 10
   def global_example():
       global x  # Declare we're using global x
       x = 5
       print(x)  # Prints 5
   
   global_example()
   print(x)  # Prints 5

3. ENCLOSING (NONLOCAL) SCOPE
   def outer():
       x = 10
       def inner():
           nonlocal x  # Use enclosing function's x
           x = 5
       inner()
       print(x)  # Prints 5
   
   outer()

===========================================================
                    DOCSTRINGS
===========================================================

1. SINGLE LINE DOCSTRING
   def greet(name):
       """Greet a person by name."""
       return f"Hello, {name}!"

2. MULTI-LINE DOCSTRING
   def calculate_area(length, width):
       """
       Calculate the area of a rectangle.
       
       Args:
           length: The length of the rectangle
           width: The width of the rectangle
       
       Returns:
           The area of the rectangle (length * width)
       """
       return length * width

3. ACCESSING DOCSTRINGS
   def example():
       """This is a docstring"""
       pass
   
   print(example.__doc__)  # This is a docstring

===========================================================
                TYPE HINTS (Python 3.5+)
===========================================================

1. BASIC TYPE HINTS
   def greet(name: str) -> str:
       return f"Hello, {name}!"

2. TYPE HINTS FOR VARIABLES
   count: int = 10
   name: str = "John"
   prices: list[float] = [1.99, 2.99, 3.99]

3. ADVANCED TYPE HINTS
   from typing import List, Dict, Tuple, Optional, Union
   
   def process_data(
       data: List[int],
       options: Optional[Dict[str, str]] = None
   ) -> Tuple[int, str]:
       """Process data with optional configuration"""
       return len(data), "processed"
   
   # Union type
   def parse_input(value: Union[int, str]) -> int:
       if isinstance(value, str):
           return int(value)
       return value

4. Callable Type HINTS
   from typing import Callable
   
   def apply_function(func: Callable[[int, int], int], a: int, b: int) -> int:
       return func(a, b)
   
   result = apply_function(lambda x, y: x + y, 5, 3)  # 8

===========================================================
                FUNCTION ANNOTATIONS
===========================================================

- Additional metadata about parameters and return values
- Stored in __annotations__ attribute

   def greet(name: str, age: int = 25) -> str:
       return f"Hello, {name}!"
   
   print(greet.__annotations__)
   # {'name': <class 'str'>, 'age': <class 'int'>, 'return': <class 'str'>}

===========================================================
                SPECIAL FUNCTION ATTRIBUTES
===========================================================

- __name__ - Function's name
- __doc__ - Function's docstring
- __defaults__ - Default argument values
- __code__ - Code object
- __globals__ - Global namespace
- __annotations__ - Type annotations

   def example(x, y=10):
       """Example function"""
       pass
   
   print(example.__name__)    # example
   print(example.__doc__)     # Example function
   print(example.__defaults__)  # (10,)

===========================================================
                    PRACTICAL EXAMPLES
===========================================================

1. VALIDATION DECORATOR
   from functools import wraps
   
   def validate_positive(func):
       @wraps(func)
       def wrapper(*args, **kwargs):
           for arg in args:
               if isinstance(arg, (int, float)) and arg < 0:
                   raise ValueError("Arguments must be positive")
           return func(*args, **kwargs)
       return wrapper
   
   @validate_positive
   def divide(a, b):
       return a / b

2. CACHE DECORATOR (Memoization)
   from functools import wraps
   
   def memoize(func):
       cache = {}
       
       @wraps(func)
       def wrapper(*args):
           if args not in cache:
               cache[args] = func(*args)
           return cache[args]
       return wrapper
   
   @memoize
   def fibonacci(n):
       if n < 2:
           return n
       return fibonacci(n-1) + fibonacci(n-2)

3. TIMING DECORATOR
   import time
   from functools import wraps
   
   def timer(func):
       @wraps(func)
       def wrapper(*args, **kwargs):
           start = time.time()
           result = func(*args, **kwargs)
           end = time.time()
           print(f"{func.__name__} took {end-start:.4f} seconds")
           return result
       return wrapper
   
   @timer
   def slow_function():
       time.sleep(1)
       print("Done!")
   
   slow_function()

4. FUNCTION COMPOSITION
   def compose(f, g):
       return lambda x: f(g(x))
   
   square = lambda x: x ** 2
   add_five = lambda x: x + 5
   
   square_after_add = compose(square, add_five)
   print(square_after_add(3))  # (3 + 5) ** 2 = 64

5. PARTIAL FUNCTION
   from functools import partial
   
   def power(base, exponent):
       return base ** exponent
   
   square = partial(power, exponent=2)
   cube = partial(power, exponent=3)
   
   print(square(5))  # 25
   print(cube(5))    # 125

===========================================================
                    BEST PRACTICES
===========================================================

1. Use meaningful function names
   def calculate_area()  # Good
   def calc()            # Bad

2. Keep functions small and focused
   - One function = One responsibility

3. Use docstrings to document functions

4. Use type hints for better code clarity

5. Use default arguments wisely
   - Default values should be immutable (None, not [])

6. Handle exceptions appropriately

7. Use *args and **kwargs for flexible functions

8. Consider using generators for large datasets

9. Use decorators to avoid code repetition

10. Write pure functions when possible
    - Same input = Same output
    - No side effects

===========================================================
                    SUMMARY
===========================================================

Functions are fundamental building blocks in Python that:
- Improve code reusability and modularity
- Make code easier to test and debug
- Support various patterns: recursion, closures, decorators
- Can be customized with parameters, arguments, and return values
- Can use advanced features like generators and type hints

Master these concepts to write clean, efficient, and Pythonic code!

===========================================================
